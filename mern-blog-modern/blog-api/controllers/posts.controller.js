import { S3Client } from "@aws-sdk/client-s3";
import { PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import mongoose from "mongoose";
import { nanoid } from "nanoid";
import { errorHandler } from "../utils/error.js";
import { generateSlug } from "../utils/slugify.js";
import { logger } from "../utils/logger.js";
import Post from "../schemas/Post.js";
import Tag from "../schemas/Tag.js";
import User from "../schemas/User.js";

const getS3Client = () => {
  return new S3Client({
    region: "us-east-2",
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    },
  });
};

const generateAWSImageUploadUrl = async () => {
  const s3Client = getS3Client();
  const date = new Date();
  const imageName = `${nanoid()}-${date.getTime()}.jpeg`;

  const command = new PutObjectCommand({
    Bucket: process.env.AWS_BUCKET_NAME,
    Key: imageName,
    ContentType: "image/jpeg",
  });
  const urlUploadImage = await getSignedUrl(s3Client, command, {
    Expires: 1000,
  });

  return urlUploadImage;
};

export const getImageUploadUrl = async (req, res, next) => {
  try {
    const urlUploadImage = await generateAWSImageUploadUrl();
    res.status(200).json({ urlUploadImage });
  } catch (error) {
    next(error);
  }
};

// Image upload from Editor.js
export const fetchImageByUrl = async (req, res, next) => {
  const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB
  const ALLOWED_TYPES = ["image/jpeg", "image/png", "image/gif", "image/webp"];

  try {
    const { url } = req.body;

    if (!url) {
      return res
        .status(400)
        .json({ success: 0, error: "Valid URL is required" });
    }

    // Validate if URL points to a VALID image
    const headResponse = await fetch(url, { method: "HEAD" });
    const contentType = headResponse.headers.get("content-type");
    const contentLength = parseInt(
      headResponse.headers.get("content-length") || "0"
    );

    // Validate image type
    if (!ALLOWED_TYPES.includes(contentType)) {
      return res.status(400).json({
        success: 0,
        error: "Invalid image type",
      });
    }

    // Validate size
    if (contentLength > MAX_IMAGE_SIZE) {
      return res.status(400).json({
        success: 0,
        error: "Image too large (max 5MB)",
      });
    }

    // Fetch the actual image
    const imageResponse = await fetch(url);
    logger.info(imageResponse);

    // Return the validated image information
    return res.status(200).json({
      success: 1,
      url: url,
      meta: {
        type: contentType,
        size: contentLength,
      },
    });
  } catch (error) {
    logger.error("500 - Failed to fetch image: ", error.message);
    return (
      res.status(500),
      json({
        success: 0,
        error: "Failed to fetch image",
      })
    );
  }
};

// Create a Post
export const createPost = async (req, res, next) => {
  const start = performance.now();
  try {
    const userId = req.user.id;
    const { title, banner, content, tags, description, draft } = req.body;

    // Validation helper function
    const validatePostData = () => {
      if (draft && !title) {
        logger.error(
          "Title empty: " + title,
          new Error("Draft - Title is empty")
        );
        return next(
          errorHandler(400, "Please provide Title field for a Draft")
        );
      }

      const requiredFields = {
        title,
        banner,
        content,
        tags,
        description,
      };
      const emptyFields = Object.entries(requiredFields).filter(
        ([key, value]) => {
          if (key === "content") return Object.keys(value).length === 0;
          if (key === "tags") return value.length === 0;
          return !value;
        }
      );

      if (emptyFields.length > 0) {
        return next(
          errorHandler(
            400,
            `Missing required fields: ${emptyFields.join(", ")}`
          )
        );
      }
    };
    validatePostData();

    // Process Tags
    const processedTags = tags.map((tag) => tag.toLowerCase().trim());
    const uniqueTags = [...new Set(processedTags)]; // Remove duplicates

    // handle tags in bulk
    const tagOperations = uniqueTags.map((tagName) => ({
      updateOne: {
        filter: { name: tagName },
        update: {
          name: tagName,
          createdBy: userId,
          // Generate slug here since bulkWrite won't trigger pre-save
          slug: generateSlug(tagName),
        },
        upsert: true,
      },
    }));
    await Tag.bulkWrite(tagOperations);
    const tagDocs = await Tag.find({ name: { $in: uniqueTags } });
    const tagIds = tagDocs.map((tag) => tag._id);

    // Create post with processed tags
    const post = new Post({
      title,
      banner,
      content,
      description,
      draft,
      tags: tagIds,
      userId,
    });

    // Save post - slug will be generated by middleware
    // Use transaction to ensure data consitency
    const session = await mongoose.startSession();
    let savedPost;

    try {
      await session.withTransaction(async () => {
        savedPost = await post.save({ session });

        await User.findByIdAndUpdate(
          userId,
          {
            $inc: { "account_info.total_posts": 1 },
            $push: { posts: savedPost._id },
          },
          { session }
        );
      });
    } finally {
      await session.endSession();
    }

    // Log performance metrics
    const duration = performance.now() - start;
    logger.info(
      `Post creation performance ${JSON.stringify({
        duration,
        userId: req.user.id,
        tagsCount: tags.length,
      })}`
    );

    // Return response
    res.status(201).json({
      success: true,
      data: savedPost,
      message: "Post created successfully",
    });
  } catch (error) {
    logger.error("Create post error:", {
      error: error.message,
      userId: req.user?.id,
      title: req.body?.title,
    });
    next(error);
  }
};

// Dynamic funtcion to get (different) post(s). Returns an Array
// `/api/post/getPosts?userId=${currentUser.user.id}`
// `/api/post/getPosts?searchTerm=javascript`  <== "javascript" in this case is a Tag
// `/api/post/getPosts?searchTerm=testing`  <== "testing" could be in the Title or Content
export const getPosts = async (req, res, next) => {
  // req.query will (probably) have
  // Query Modifiers: startIndex, limit, order,
  // Conditions: userId, slug, searchTerm
  logger.info(`SEARCH: ${req.query.searchTerm}`);

  // Query modifiers
  const startIndex = parseInt(req.query.startIndex) || 0;
  const limit = parseInt(req.query.limit) || 10;
  const sortDirection = req.query.order === "asc" ? 1 : -1;
  const latest = req.query.latest;
  const latestLimit = req.query.latest ? parseInt(req.query.latest) || 5 : null;

  /**  
   * Building dynamic query objects:
    The spread operator with a logical AND is a concise way to conditionally add properties to an object.
    If the AND returned an object, it spreads its properties into the parent object.
  
    ...("123" && { _id: "123" })
    Becomes: _id: "123"
    ...(undefined && { _id: undefined })
    Becomes: nothing (no properties added)
    Or in a ore verbose way:
    let query = {};
    if (req.query.postId) {
        query._id = req.query.postId;
    }
   */
  try {
    const posts = await Post.find({
      draft: false,
      // by postId
      ...(req.query.postId && { _id: req.query.postId }),
      // by user id
      ...(req.query.userId && { userId: req.query.userId }),
      // by slug
      ...(req.query.slug && { slug: req.query.slug }),
      // by search term
      ...(req.query.searchTerm && {
        $or: [
          { title: { $regex: `.*${req.query.searchTerm}.*`, $options: "i" } },
          {
            description: {
              $regex: `.*${req.query.searchTerm}.*`,
              $options: "i",
            },
          },
          // TODO: Fix the search in the content field or Find another RTE
          // { content: { $regex: `.*${req.query.searchTerm}.*`, $options: "i" } },
          {
            tags: {
              $in: (
                await Tag.find({
                  name: {
                    $regex: `.*${req.query.searchTerm}.*`,
                    $options: "i",
                  },
                }).select("_id")
              ).map((tag) => tag._id),
            },
          },
        ],
      }),
    })
      .populate(
        "userId",
        "personal_info.fullname personal_info.profile_img personal_info.username"
      )
      .populate("tags", "name slug -_id")
      .sort({ createdAt: latest ? -1 : sortDirection }) // if latest, sort by newest
      .select(
        `slug title description banner ${
          req.query.slug ? " content activity" : " content"
        } createdAt -_id`
      )
      .skip(latest ? 0 : startIndex) // if latest, don't skip
      .limit(latestLimit || limit);

    logger.info(`==> POSTS: ${posts[0]}`);
    logger.info(`==> POSTS.content: ${typeof posts[0].content}`);
    logger.info(`==> POSTS.content.blocks: ${typeof posts[0].content.blocks}`);
    logger.info(`==> POSTS: ${posts[0].content.blocks}`);

    // Will show "string" if stringified or "object" if not
    res.status(200).json({ posts });
  } catch (error) {
    next(error);
  }
};
